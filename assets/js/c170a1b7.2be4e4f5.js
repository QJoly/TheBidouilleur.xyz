"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[7104],{4137:(e,t,n)=>{n.d(t,{Zo:()=>c,kt:()=>f});var r=n(7294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)n=s[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),u=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},c=function(e){var t=u(e.components);return r.createElement(l.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,s=e.originalType,l=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),p=u(n),d=a,f=p["".concat(l,".").concat(d)]||p[d]||m[d]||s;return n?r.createElement(f,i(i({ref:t},c),{},{components:n})):r.createElement(f,i({ref:t},c))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var s=n.length,i=new Array(s);i[0]=d;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o[p]="string"==typeof e?e:a,i[1]=o;for(var u=2;u<s;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},4125:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>m,frontMatter:()=>s,metadata:()=>o,toc:()=>u});var r=n(7462),a=(n(7294),n(4137));const s={title:"NFS avec provisionnement dynamique",slug:"nfs",description:"Utiliser le provisionnement dynamique avec NFS sur Kubernetes"},i=void 0,o={unversionedId:"Kubernetes/nfs-pv",id:"Kubernetes/nfs-pv",title:"NFS avec provisionnement dynamique",description:"Utiliser le provisionnement dynamique avec NFS sur Kubernetes",source:"@site/docs/Kubernetes/nfs-pv.md",sourceDirName:"Kubernetes",slug:"/Kubernetes/nfs",permalink:"/TheBidouilleur.xyz/docs/Kubernetes/nfs",draft:!1,editUrl:"https://github.com/QJoly/TheBidouilleur.xyz/tree/main/docs/Kubernetes/nfs-pv.md",tags:[],version:"current",lastUpdatedAt:1688742889,formattedLastUpdatedAt:"7 juil. 2023",frontMatter:{title:"NFS avec provisionnement dynamique",slug:"nfs",description:"Utiliser le provisionnement dynamique avec NFS sur Kubernetes"},sidebar:"tutorialSidebar",previous:{title:"Kubectl sur machine cliente",permalink:"/TheBidouilleur.xyz/docs/Kubernetes/kube-client"},next:{title:"Utilisation d'un registre priv\xe9",permalink:"/TheBidouilleur.xyz/docs/Kubernetes/registre-prive"}},l={},u=[],c={toc:u},p="wrapper";function m(e){let{components:t,...n}=e;return(0,a.kt)(p,(0,r.Z)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Apr\xe8s quelques rares mauvaises surprises avec le provisionnement dynamique de Longhorn, j'ai d\xe9cid\xe9 de me tourner vers une seconde solution de provisionnement dynamique pour Kubernetes. J'ai choisi NFS, car c'est une solution simple et efficace ",(0,a.kt)("em",{parentName:"p"},"(et qu'il permet toujours de faire de la HA avec un cluster GlusterFS)"),"."),(0,a.kt)("p",null,"L'installation est assez simple et se fait en 2 \xe9tapes :"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"Installation du Helm"),(0,a.kt)("li",{parentName:"ul"},"Cr\xe9ation du storageClass")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"helm repo add csi-driver-nfs https://raw.githubusercontent.com/kubernetes-csi/csi-driver-nfs/master/charts\\n\nhelm repo update\nhelm install csi-driver-nfs csi-driver-nfs/csi-driver-nfs \\ \n    --namespace kube-system\n")),(0,a.kt)("p",null,"Avant de passer \xe0 la suite, je vous invite \xe0 v\xe9rifier que le d\xe9ploiement s'est bien pass\xe9. ",(0,a.kt)("em",{parentName:"p"},"(via k9s ou la commande suivante)")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl wait pod --selector app.kubernetes.io/name=csi-driver-nfs --for condition=ready --namespace kube-system\n")),(0,a.kt)("p",null,"Une fois le Helm d\xe9ploy\xe9, il faut maintenant cr\xe9er le storageClass ",(0,a.kt)("em",{parentName:"p"},"(qui aura pour but de g\xe9rer nos PersistentVolumeClaim)"),". Celui-ci doit contenir les param\xe8tres du serveur NFS ainsi que le chemin du partage. ",(0,a.kt)("em",{parentName:"p"},"(\xe0 adapter selon votre configuration, la syntaxe est la m\xeame pour un cluster GlusterFS)")),(0,a.kt)("p",null,"Voici un exemple de storageClass :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: storage.k8s.io/v1\nkind: StorageClass\nmetadata:\n  name: nfs-csi\nprovisioner: nfs.csi.k8s.io\nparameters:\n  server: 192.168.1.20\n  share: /volume1/k3s/pvc\nreclaimPolicy: Delete\nvolumeBindingMode: Immediate\nmountOptions:\n  - hard\n  - nfsvers=4.1\n")),(0,a.kt)("p",null,"On peut v\xe9rifier que la cr\xe9ation du storageClass s'est bien pass\xe9e avec la commande suivante :"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-bash"},"kubectl get storageclasses.storage.k8s.io                \nNAME                   PROVISIONER             RECLAIMPOLICY   VOLUMEBINDINGMODE      ALLOWVOLUMEEXPANSION   AGE\nlonghorn (default)     driver.longhorn.io      Delete          Immediate              true                   317d\nlocal-path             rancher.io/local-path   Delete          WaitForFirstConsumer   false                  317d\nnfs-csi                nfs.csi.k8s.io          Delete          Immediate              false                  3s\n")),(0,a.kt)("p",null,"Et maintenant ? Il ne vous reste plus qu'\xe0 cr\xe9er vos PersistentVolumeClaim."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-yaml"},"apiVersion: v1\nkind: PersistentVolumeClaim\nmetadata:\n  name: nfs-pvc\nspec:\n  accessModes:\n    - ReadWriteMany\n  resources:\n    requests:\n      storage: 10Gi\n  storageClassName: nfs-csi\n")))}m.isMDXComponent=!0}}]);